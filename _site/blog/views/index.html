<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
            <meta property="og:title" content="Views" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://ychbn.com/blog/views/" />




	<link rel="stylesheet" type="text/css" href="/bundle/FR2Cbd8xic.css">

	<title>
      
        Views
      

    </title>
  </head>
  <body>
	
<div class="page-container">
    <div>
        
        	<div class="header">
	<span class="header__item ">Ychbn</span>
</div>
        

        <div class="nav">
	<div class="nav__items ">
			<a  class="nav__item " href="/"> Home </a>
			<a  class="nav__item " href="/blog/"> Blog </a>
	</div>
</div>

        <div class="container stack">
        	
        		<h1> Views</h1>
        	

            

        	<h2 id="what-are-views" tabindex="-1">What are views</h2>
<p>Views are objects in a database, which:</p>
<ol>
<li>Look like a table</li>
<li>Contain inside themselves a SQL query, by which a view is replaced when it's
used.</li>
</ol>
<p>Views work like tables in many ways. We can (with some restrictions)
insert, update and delete data from them.</p>
<h2 id="creating-views" tabindex="-1">Creating views</h2>
<p>General syntax is:</p>
<pre><code>create view viewname as
select ...
...
...;
</code></pre>
<p>It means that a SQL query with needed data is enough for view creation.
We can create views with <code>or replace</code> option, and then, if the view with
such name already exists, it will be overwritten.</p>
<pre><code>create or replace view viewname as
select ...
...
...;
</code></pre>
<p>Let's create tables for employees, posts and departments:</p>
<pre><code>create table employees(
id number,
emp_name varchar2(100 char),
dept_id number,
position_id number
);

create table departments(
id number,
dept_name varchar2(100)
);

create table positions(
id number,
position_name varchar2(100)
);

insert into departments values(1, 'IT');
insert into departments values(2, 'SALARY');
insert into positions values(1, 'MANAGER');
insert into positions values(2, 'CLERK');
insert into employees values(1, 'Ivan Boika', 1, 1);
insert into employees values(2, 'John Rosenshteiner', 1, 2);
insert into employees values(3, 'Philipp Dauhn', 2, 1);
insert into employees values(4, 'Sid Vicious', 2, 2);
</code></pre>
<p>Now, let's create a <code>vemployees</code> view, which will contain data about
employees from all these tables in a &quot;joined&quot; state:</p>
<pre><code>create view vemployees as
select e.id,
e.emp_name,
d.dept_name,
p.position_name
from employees e
join departments d on d.id = e.dept_id
join positions p on p.id = e.position_id;

comment on table vemployees is 'employees';
comment on column vemployees.id is 'employee id';
comment on column vemployees.emp_name is 'employee name';
comment on column vemployees.dept_name is 'department';
comment on column vemployees.position_name is 'position';
</code></pre>
<p>Note that views and their columns may contain comments like
ordinary tables in Oracle.</p>
<p>Now, to get interested data, we don't have to write SQL query
again, it's enough to get it from the view:</p>
<pre><code>select *
from vemployees
</code></pre>
<pre><code>+----+--------------------+-----------+---------------+
| ID |      EMP_NAME      | DEPT_NAME | POSITION_NAME |
+----+--------------------+-----------+---------------+
|  1 | Ivan Boika         | IT        | MANAGER       |
|  3 | Philipp Dauhn      | SALARY    | MANAGER       |
|  2 | John Rosenshteiner | IT        | CLERK         |
|  4 | Sid Vicious        | SALARY    | CLERK         |
+----+--------------------+-----------+---------------+
</code></pre>
<p>We can use existing views to create other views:</p>
<pre><code>create view vemployees_it as
select a.*
from vemployees a
where a.dept_name = 'IT';
</code></pre>
<p>We should carefully use existing views as build blocks for new ones.
It may turn out that it's better to write completely new SQL query which
is more optimal for specific task.</p>
<h2 id="*-symbol" tabindex="-1">* Symbol</h2>
<p>When Oracle meets <code>*</code> in a view's definition, it replaces an asterics
with the list of columns returned by the query. It means that if
a new column is added to some table, Oracle won't add it to the view.
It's pretty easy to check:</p>
<pre><code>create table tst(
n1 number,
n2 number
);

insert into tst values(1, 2);

create view v_tst as
select *
from tst;
</code></pre>
<p>Let's see what data is in the view:</p>
<pre><code>select *
from v_tst
</code></pre>
<pre><code>+----+----+
| N1 | N2 |
+----+----+
|  1 |  2 |
+----+----+
</code></pre>
<p>Now let's add a column to the <code>tst</code> table:</p>
<pre><code>alter table tst
add (n3 number);
</code></pre>
<p>If we look at the view, we will see that column's list
hasn't changed:</p>
<pre><code>+----+----+
| N1 | N2 |
+----+----+
|  1 |  2 |
+----+----+
</code></pre>
<p>To add the <code>n3</code> column to the view, we can change it by adding this
column to the columns list, or recreate the view again (with <code>create or replace</code>):</p>
<pre><code>create or replace view v_tst as
select *
from tst
</code></pre>
<h2 id="modify-view-data" tabindex="-1">Modify view data</h2>
<p>Tables that are used in a view are called &quot;base tables&quot;.
Views that are created from one base table can be changed like an ordinary table.
For example, let's create <code>vdepartments</code> view and add some rows to it.</p>
<pre><code>-- Create a view
create view vdepartments as
select id, dept_name
from departments;

-- Insert row through the view, not through a table
insert into vdepartments(id, dept_name)
values(10, 'SALES');
</code></pre>
<p>Of course, a row is inserted into a base table ( the <code>department</code> table
in this case).</p>
<p>We can also delete and update rows in a base table:</p>
<pre><code>delete from vdepartments
where id = 10;

update vdepartments
set dept_name = 'SECURITY'
where id = 1;
</code></pre>
<p>Let's look at the view:</p>
<pre><code>select *
from vdepartments
</code></pre>
<p>Result:</p>
<pre><code>+----+-----------+
| ID | DEPT_NAME |
+----+-----------+
|  1 | SECURITY  |
|  2 | SALARY    |
+----+-----------+
</code></pre>
<h2 id="views-with-check-option" tabindex="-1">Views with check option</h2>
<p>We can create view which will restrict data changing  in
base tables. <code>WITH CHECK OPTION</code> option is used for this during
view creation.</p>
<p>Let's create a view with managers only:</p>
<pre><code>create view vemp_managers as
select *
from employees
where position_id = 1
</code></pre>
<p>This view contains only managers, but it doesn't mean that
we can't insert into it employees with a different position:</p>
<pre><code>-- Add an employee with position_id = 2
insert into vemp_managers(id, emp_name, dept_id, position_id)
values(10, 'John Doe', 1, 2);
</code></pre>
<p>After that, the view looks the same:</p>
<pre><code>select *
from vemp_managers
</code></pre>
<pre><code>+----+---------------+---------+-------------+
| ID |   EMP_NAME    | DEPT_ID | POSITION_ID |
+----+---------------+---------+-------------+
|  1 | Ivan Boika    |       1 |           1 |
|  3 | Philipp Dauhn |       2 |           1 |
+----+---------------+---------+-------------+
</code></pre>
<p>But the <code>employees</code> table itself now has new rows:</p>
<pre><code>select *
from employees
</code></pre>
<pre><code>+----+--------------------+---------+-------------+
| ID |      EMP_NAME      | DEPT_ID | POSITION_ID |
+----+--------------------+---------+-------------+
| 10 | John Doe           |       1 |           2 |
|  1 | Ivan Boika         |       1 |           1 |
|  2 | John Rosenshteiner |       1 |           2 |
|  3 | Philipp Dauhn      |       2 |           1 |
|  4 | Sid Vicious        |       2 |           2 |
+----+--------------------+---------+-------------+
</code></pre>
<p>In order to be able to modify only rows that a view has, <code>with check option</code>
option is used. Let's try this way:</p>
<pre><code>create or replace view vemp_managers as
select *
from employees
where position_id = 1
with check option;

insert into vemp_managers(id, emp_name, dept_id, position_id)
values(11, 'John Doe', 1, 2);
</code></pre>
<p>We'll get the <code>view WITH CHECK OPTION where-clause violation</code>
exception if we run example above.</p>
<h2 id="modify-views-that-are-made-up-of-multiple-tables" tabindex="-1">Modify views that are made up of multiple tables</h2>
<p>In Oracle, we can change data via views that are
made up of multiple tables, but with some restrictions:</p>
<ol>
<li>It's possible to change only one base table</li>
<li>Affected table should be a &quot;key preserved table&quot;.</li>
</ol>
<p>The last point is the most important for understanding whether
data can be changed  in a multi-table view or not. So, a table is key preserved,
if each of its rows has at most one row in a view.</p>
<p>It should be remembered that key preserved property doesn't depend
on data, but rather on tables' structure and relations between them.
In fact, data in a view may look like that for one row in a
base table there's one row in the view. But it doesn't mean
that this property will not be changed after data modifications in
tables inside the view.</p>
<p>For demonstration, we're going to create a <code>vemp_depts</code> view, which
will contain information about employees and their departments:</p>
<pre><code>create or replace view vemp_depts as
select e.id,
       e.emp_name,
       e.dept_id,
       e.position_id,
       d.id department_id,
       d.dept_name
from employees e
join departments d on e.dept_id = d.id
</code></pre>
<p>Let's see what's inside this view:</p>
<pre><code>select *
from vemp_depts
</code></pre>
<pre><code>+----+--------------------+---------+-------------+---------------+-----------+
| ID |      EMP_NAME      | DEPT_ID | POSITION_ID | DEPARTMENT_ID | DEPT_NAME |
+----+--------------------+---------+-------------+---------------+-----------+
| 10 | John Doe           |       1 |           2 |             1 | SECURITY  |
|  1 | Ivan Boika         |       1 |           1 |             1 | SECURITY  |
|  2 | John Rosenshteiner |       1 |           2 |             1 | SECURITY  |
|  3 | Philipp Dauhn      |       2 |           1 |             2 | SALARY    |
|  4 | Sid Vicious        |       2 |           2 |             2 | SALARY    |
+----+--------------------+---------+-------------+---------------+-----------+
</code></pre>
<p>As we can see, each row from the  <code>employees</code> base table apppears
only once in the <code>vemp_depts</code> view. Now, let's try to add new employee
through this view:</p>
<pre><code>insert into vemp_depts(id, emp_name, dept_id, position_id)
values(20, 'Johny Belaco', 1, 1);
</code></pre>
<p>As a result, we're getting an &quot;cannot modify a column which maps to a non key-preserved&quot; error, which tells us
that the table doesn't meet the requirements for
updating it through the view.</p>
<p>We know that the problem is not with data, but with database structure.
Let's see how we've created our table and how our query looks inside the view:</p>
<pre><code>-- This is what is inside the view
select e.id,
       e.emp_name,
       e.dept_id,
       e.position_id,
       d.id department_id,
       d.dept_name
from employees e
join departments d on e.dept_id = d.id
</code></pre>
<p>Here, we get each row from the <code>employees</code> table and join it with
the <code>departments</code> table by the <code>dept_id</code> field. In which case it may
be happened that inside the view there will be two records after
joining one single row from the <code>employees</code> table with the <code>departments</code> table?
Right, when there are two rows in the <code>departments</code> table with the same
value in the <code>id</code> field. Now there are no such rows, but it doesn't mean
that they will not appear. Now, we have to remember how we have created
the <code>department</code> table:</p>
<pre><code>create table departments(
    id number,
    dept_name varchar2(100)
)
</code></pre>
<p>There are no any restrictions for the <code>id</code> column. But we can make it
unique by adding a primary or unique key:</p>
<pre><code>alter table departments
add (
    constraint departments_pk primary key(id)
)
</code></pre>
<p>Now, if we try to add a new employee, everything will be fine:</p>
<pre><code>-- A row will be added without errors
insert into vemp_depts(id, emp_name, dept_id, position_id)
values(20, 'Random Employee', 1, 1);
</code></pre>
<p>It should me mentioned that it's impossible to insert rows into
the <code>departments</code> table via this view:</p>
<pre><code>-- cannot modify a column which maps to a non key-preserved table
insert into vemp_depts(department_id, dept_name)
values(7, 'HEAD DEPARTMENT')
</code></pre>
<p>The reason is still the same - it's not guaranteed that each employee in the
<code>employees</code> table has a unique value of the <code>dept_id</code> field.</p>
<h3 id="restrictions-on-changing-data-via-views" tabindex="-1">Restrictions on changing data via views</h3>
<p>There're some cases when changing base tables through a view is not possible:</p>
<ol>
<li>If view has aggregate functions, <code>group by</code> constructions, <code>distinct</code> operator,
as well as union operators (<code>union</code>, <code>union all</code>, <code>intersect</code>)</li>
<li>If data isn't satisfy conditions in <code>WITH CHECK OPTION</code> clause</li>
<li>If some column in a base table is <code>NOT NULL</code>, doesn't have default value and
doesn't exist in the view</li>
<li>If columns in a view are expressions (something like <code>nvl(a.value, -1)</code>)</li>
</ol>
<h2 id="prohibition-of-data-modification-through-views" tabindex="-1">Prohibition of data modification through views</h2>
<p>To create a read-only view, we can use the  <code>with read only</code> modificator:</p>
<pre><code>-- Create a read only view
create or replace view vdepartments as
select id, dept_name
from departments
with read only;

-- let's try to insert a row
insert into vdepartments(id, dept_name)
values(11, 'SECURITY');
</code></pre>
<p>As a result, we get an  <code>cannot perform a DML operation on a read-only view</code> error.</p>

        </div>
    </div>
    <div class="footer-container">
        <div class="footer">
	<div class="container">
		2023
	</div>
</div>
    </div>
</div>

  </body>
</html>
