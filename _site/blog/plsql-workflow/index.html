<!DOCTYPE html>
<html>
  <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
            <meta property="og:title" content="" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://ychbn.com/blog/plsql-workflow/" />




	<link rel="stylesheet" type="text/css" href="/bundle/FR2Cbd8xic.css">

	<title>
      
        Ychbn
      

    </title>
  </head>
  <body>
	
<div class="page-container">
    <div>
        
        	<div class="header">
	<span class="header__item ">Ychbn</span>
</div>
        

        <div class="nav">
	<div class="nav__items ">
			<a  class="nav__item " href="/"> Home </a>
			<a  class="nav__item " href="/blog/"> Blog </a>
	</div>
</div>

        <div class="container stack">
        	

            

        	<p>In this article I'll try to summarize must-have practices
for dealing with DB-related code in your
projects. If the main language of
your project is PL/SQL, I hope you will not read anything
new here, but I encourage you to read it anyway.</p>
<p><strong>Summary</strong>: SQL and PL/SQL is code, too.
Comment it, keep it under version control.
Use packages and avoid using standalone procedures/functions.
Avoid non-packaged code in scheduled jobs and aim to reduce
triggers usage.</p>
<h2 id="keep-any-db-related-code-in-source-code-files" tabindex="-1">Keep any db related code in source code files</h2>
<p>If you're working with DB objects
directly in the database, I have bad news for you.</p>
<p>Most probably, you keep your main (frontend, or backand)
source code under version control system, and you may list
at least a few benefits of doing so.  But if your PL/SQL
code (and anything related to the database)
is the part of your project, why it should be ignored?</p>
<p>It's a simple truth, but here are main advantages of
using VCS (Version Control System) for PL/SQL and database code:</p>
<ul>
<li>VCS allows many developers work on a single package.
Many conflicts will be handled automatically, or at least
you will see what other developers want to do with the
same part you're working on</li>
<li>Revert changes</li>
<li>Commit messages can help you to understand business logic</li>
</ul>
<p>Database code is the most difficult to work on it for more than
one developer if it isn't under version control and exists only
in the database.</p>
<p>Imagine - you're working on some function in a package,
and you've just modified its business-logic. At the same
time, another one developer has changed another function
<em>in the same package</em>. How will this package work when
you both compile it? <strong>You don't know</strong> (who is the last?).</p>
<p>Another one situation is more fatal - <strong>someone may drop
your package/function/view</strong> and you can't say why he did it
and how to revert these changes.</p>
<p>I recommend <strong>to keep these object as source code files and keep them
versioned:</strong></p>
<ul>
<li>packages</li>
<li>triggers</li>
<li>views</li>
<li>jobs</li>
<li>standalone functions/procedures</li>
</ul>
<p>The directory structure may be organized like this:</p>
<pre><code>project name
|
+--DB
   |
   +--packages
   +--views
   +--triggers
   +--jobs
   +--standalone
</code></pre>
<h2 id="workflow-example" tabindex="-1">Workflow example</h2>
<p>Let's imagine that you've decided to write a view with
active users. First, you have to pick a name for it respectively
to your company's guidelines. Once you did it, open your IDE or a text editor
and create a file for view (for example, <code>vactive_users.sql</code>). Then start writing
a sql query:</p>
<pre><code>-- File: projectname/DB/views/vactive_users.sql
-- This view returns currently active users.
-- Note that we also don't want deleted users to
-- be in the result.
-- TODO: Create functional index on `deleted_at` column
select u.login,
       u.reg_date,
       u.email,
       .......
from users u
where u.deleted_at is null
and u.is_active = 0;

comment on table vactive_users is 'Only active users';
</code></pre>
<p>When you think you're done, <strong>save the file first</strong>, and then compile it.
Then, fix any syntaxic or logical errors and <strong>save the file again</strong>.
Then compile it again and repeat previous steps untill the view is finished.
At the end, <strong>add file <code>vactive_users.sql</code> to the VCS you use</strong>.</p>
<pre><code class="language-goat">+--------------+   +------------+   +--------------+    +-----+ Yes +----------+
|  Create file +--&gt;| Write code +--&gt;|Save, compile +---&gt;| OK? +----&gt;|Add to VCS|
+--------------+   +------------+   +--------------+    +-+---+     +----------+
                        ^     No                          |
                        +---------------------------------+
</code></pre>
<p>This approach (keeping DB objects in VCS) allows to work on your project in a more consistent way,
because now all your source code lies in the project's repository. You always can open any
package/view/function without necessity to connect to the Oracle (for example, you
may working on a web backend module and forget which fields contains some view, or which fields
returns some procedure/cursor, and so on. In such situations you just quickly open required file and
you're done).</p>
<p>I believe it's also a good idea to document views right in sql files.
At the beginning of the file the view is documented like it's ordinary code - what this view is about,
why do we need it, where to use it, maybe some comment-only directives (like <code>TODO</code> in the example
above). I use database comments (Oracle's <code>comment on vactive_users is 'View for active users'</code>)
only for short summary description.</p>
<h2 id="use-packages-as-much-as-possible" tabindex="-1">Use packages as much as possible</h2>
<p>Packages consist from two parts - specification and implementation.
It's better to split them into two files. I personally prefer
to save specification with <code>*.pks</code> extension (Package specification), and
implemendation with <code>*.pkb</code> (Package body).</p>
<p>I can't imagine Oracle-driven development without using packages.
They not only allow to group functions/procedures into modules, but
also support incapsulation and have package-level state.</p>
<p>Packing functions into a package also increases code readability. Compare
these two examples:</p>
<pre><code>declare
    l_change_user_id app_users.id%type := 100;
    l_del_user_id    app_users.id%type := 120;
    l_change_emp_id  employees.id%type := 100;
    l_del_emp_id     employees.id%type := 120;
begin
    del_user(l_del_user_id);
    change_name(l_change_user_id, 'Mike76');
    change_emp_name(l_change_emp_id, 'John');
    del_employee(l_del_emp_id);
end;
</code></pre>
<pre><code>declare
    l_change_user_id app_users.id%type := 100;
    l_del_user_id    app_users.id%type := 120;
    l_change_emp_id  employees.id%type := 100;
    l_del_emp_id     employees.id%type := 120;
begin
    -- It's clear that user will be deleted,
    -- not employee
    pck_users.delete(l_del_user_id);
    pck_users.change_name(l_change_user_id, 'Mike76');
    pck_employee.change_name(l_change_emp_id, 'John');
    pck_employee.delete(l_del_semp_id);
end;
</code></pre>
<p>In the first example, we use global procedures, while in the second -
packages. Note that we have to use different names for similar tasks in the
first example - procedures <code>delete_user</code> and <code>delete_employee</code> have the
same parameters signature, and we can't give them the same name.</p>
<p>With packages, it's not a problem at all. Similar tasks have the same name
across packages. Package name works like &quot;context&quot;, simplifying understanding
of what your code actually does.</p>
<p>It's just one of the many advantages of using packages. I'll list a few more
soon.</p>
<h2 id="avoid-using-triggers" tabindex="-1">Avoid using triggers</h2>
<p>Triggers complicate the flow of your program and
don't allow you to see its &quot;whole picture&quot;.</p>
<p>Let's try to implement new feature in our system -
user deletion. When user is being deleted, all
pending orders of this user should be transitioned to
the 'Closed' status.</p>
<p>With triggers, you have to write a trigger on the <code>users</code>
table, which will update status in the <code>orders</code> table.
Very simple, you may say, but even such a simple
example illustrates how triggers suck for this task.</p>
<p>First, how will we launch the user deletion process?
We don't want to delete rows from the database, because
we use so called &quot;soft delete&quot; (it's when <code>deleted_at</code> column is
filled with deletion date). Therefore, anywhere in our program
we have to write something like this:</p>
<pre><code>begin
    update app_users
    set deleted_at = systimestamp
    where id = l_user_id;
end;
</code></pre>
<p>Imagine that you watch at this code half a year later.
What this code actually tells you? It tells that
<code>deleted_at</code> column is updated. That's all. You have to
always remember that <strong>exactly this SQL</strong> is the user deletion.
And you don't know anything about what the hell is going on
after this.</p>
<p>Also, the trigger will run everytime when the <code>users</code> table is updated, and
we have to handle such situations, something like this:</p>
<pre><code>create or replace trigger user_bu
-- We can also create trigger that will listen
-- updates only on deleted_at column, but it doesn't
-- change anything
before update
on table users
....
   if :new.deleted_at is not null and :old.deleted_at is null then
       update orders o
       set o.status = 'CLOSED'
       where o.user_id = :old.id
       and o.status = 'PENDING';
   end if;

</code></pre>
<p>And this is just for user deletion. This trigger will grow
everytime we need to add another one feature related to the
<code>users</code> table.</p>
<p>This is how the same task would look like if
we used packages:</p>
<pre><code>declare
    l_user_id app_users.id%type := 100;
begin
    pck_users.delete(l_user_id);
end;
</code></pre>
<p>Now, when a developer see this code,
he will know that it deletes the user, because
<code>pck_users.delete(l_user_id)</code> string is verbal.
Let's imagine that the developer would know how
exactly user deletion works. He opens the
<code>pck_users.pkb</code> file and searches for the <code>delete</code> procedure:</p>
<pre><code>...
procedure delete(
   puser_id app_users.id%type
)
is
begin
   update app_users
   set deleted_at = systimestamp
   where id = puser_id;

   update orders o
   set o.status = 'CLOSED'
   where o.user_id = puser_id
   and o.status = 'PENDING';
end;
...
</code></pre>
<p>Now, the picture is clear.</p>
<p>There're many benefits of using packages over triggers, I'll list just some of them:</p>
<ul>
<li>packages are  verbal and give understanding about what part of the business logic is affected</li>
<li>they separate interface and implementation</li>
<li>you can control execution privilleges to them</li>
<li>they work on a more high-level abstraction levels than triggers</li>
</ul>
<h3 id="when-triggers-are-fine" tabindex="-1">When triggers are fine</h3>
<ul>
<li>Audit triggers</li>
<li>Autofill some values</li>
<li>Prevent table from being changed</li>
</ul>
<h2 id="don't-use-complicated-code-in-scheduled-jobs" tabindex="-1">Don't use complicated code in scheduled jobs</h2>
<p>Ok, here is an example of how you can create scheduled job in
Oracle:</p>
<pre><code>BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
   job_name                 =&gt;  'my_new_job2',
   job_type                 =&gt;  'PLSQL_BLOCK',
   job_action               =&gt;  'BEGIN SALES_PKG.UPDATE_SALES_SUMMARY; END;',
   schedule_name            =&gt;  'my_saved_schedule');
END;
/
</code></pre>
<p><strong>This example is fine</strong>. But please, don't create scheduled jobs like this:</p>
<pre><code>BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
   job_name                 =&gt;  'my_new_job2',
   job_type                 =&gt;  'PLSQL_BLOCK',
   job_action               =&gt;  'DECLARE' ||
   'l_id number;' ||
   'BEGIN' ||
   'select id into l_id from some_table;' ||
   'delete from another_table where id = l_id;' ||
   'END;'
   schedule_name            =&gt;  'my_saved_schedule');
END;
</code></pre>
<p>Instead, <strong>move complicated code into a package-level procedure</strong>, like in the first
example.</p>

        </div>
    </div>
    <div class="footer-container">
        <div class="footer">
	<div class="container">
		2023
	</div>
</div>
    </div>
</div>

  </body>
</html>
